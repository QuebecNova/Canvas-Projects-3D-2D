// Define the constants based on our bit allocation using BigInt
const BITS_X = 19n
const BITS_Y = 14n
const BITS_Z = 19n

// Calculate the masks
const MASK_X = (1n << BITS_X) - 1n // 2^19 - 1 = 524,287
const MASK_Y = (1n << BITS_Y) - 1n // 2^14 - 1 = 16,383
const MASK_Z = (1n << BITS_Z) - 1n // 2^19 - 1 = 524,287

// Define the min values for our chosen range to handle negatives
const MIN_X = -(1n << (BITS_X - 1n)) // -2^18 = -262,144
const MIN_Z = -(1n << (BITS_Z - 1n)) // -2^18 = -262,144

// Y range is (0, 16383] which means 1 to 16383 inclusive
const MIN_Y = 0n
const MAX_Y = 16383n

/**
 * Encodes (x, y, z) coordinates into a single, unique BigInt key.
 * @param {number} x Must be in range [-262144, 262143]
 * @param {number} y Must be in range [0, 16383]
 * @param {number} z Must be in range [-262144, 262143]
 * @returns {bigint} The 52-bit key.
 */
export function coordinatesToKey(x: number, y: number, z: number) {
    // Convert inputs to BigInt to avoid precision issues
    const xBig = BigInt(x)
    const yBig = BigInt(y)
    const zBig = BigInt(z)
    // 1. Normalize coordinates to non-negative integers
    const normalizedX = xBig - MIN_X // Now in range [0, 524287]
    const normalizedY = yBig - MIN_Y // Now in range [0, 16383]
    const normalizedZ = zBig - MIN_Z // Now in range [0, 524287]

    // 2. Validate
    if (normalizedX < 0n || normalizedX > MASK_X) {
        throw new Error(`X value ${x} is out of range. Must be between ${MIN_X} and ${Number(MIN_X + MASK_X)}`)
    }
    if (normalizedY < 0n || normalizedY > MASK_Y) {
        throw new Error(`Y value ${y} is out of range. Must be between ${Number(MIN_Y)} and ${Number(MAX_Y)}`)
    }
    if (normalizedZ < 0n || normalizedZ > MASK_Z) {
        throw new Error(`Z value ${z} is out of range. Must be between ${MIN_Z} and ${Number(MIN_Z + MASK_Z)}`)
    }

    // 3. Pack the bits using BigInt operations
    const key = (normalizedX << (BITS_Y + BITS_Z)) | (normalizedY << BITS_Z) | normalizedZ
    return key
}

/**
 * Decodes a BigInt key back into the original (x, y, z) coordinates.
 * @param {bigint} key The key generated by coordinatesToKey
 * @returns {[number, number, number]} The [x, y, z] tuple as Numbers
 */
export function keyToCoordinates(key: BigInt) {
    // Validate input is a BigInt
    if (typeof key !== 'bigint') {
        throw new Error('Key must be a BigInt')
    }

    // Extract the components using bit masks and shifts
    const normalizedZ = key & MASK_Z
    const normalizedY = (key >> BITS_Z) & MASK_Y
    const normalizedX = (key >> (BITS_Y + BITS_Z)) & MASK_X

    // Denormalize back to the original ranges
    const x = Number(normalizedX + MIN_X)
    const y = Number(normalizedY + MIN_Y) // Add back the MIN_Y offset
    const z = Number(normalizedZ + MIN_Z)

    return [x, y, z]
}
